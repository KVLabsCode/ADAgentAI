Video 1

teams often set up a production-like environment known as staging where they test and validate new features before releasing them here's what a typical flow looks like a developer sets up their local development environment where they start developing a new feature once they're happy with their changes locally they deploy to a staging environment where the feature then gets reviewed by stakeholders once everyone is happy you deploy to production now while this flow works it is far from ideal when you have several developers collaborating on the same project that's because a staging environment can break this could be due to a bad release or a bad database migration that happens and when that happens well the entire team is blocked and is unable to preview their changes now another scenario is when a developer wants to test their changes in isolation and they don't want someone else's work to affect theirs so what will happen is the entire team will also be unable to preview their changes throughout that period and finally this pattern kind of forces you into doing a big release which includes several changes at once so what happens is when you actually release and something goes wrong unexpectedly and you're not sure what is the cause well you're gonna have to undo all of your changes now thankfully a new pattern is becoming increasingly more popular in its preview environments rather than having a shared and fixed staging where all developers collaborate you automatically provision a production-like environment for every new code change you want to introduce this way developers can build new features in parallel without affecting each other and you can easily reverse changes if something goes wrong this enables you to ship new features faster and with more confidence now a lot of deployment platforms are storing support this flow out of the box by enabling you to set up an automatic git integration this way you don't have to worry about maintaining and managing the necessary infrastructure for handling this type of law here's an example this is neon's website it's built using nexjs and associ now let's say I want to make a change I want to update this Banner to say join us on March 29th for developer days number two so to do that I have the project locally installed on my machine I will first create a new give branch check out HB and let's call it update Banner text and then I'll make my changes so I'll go here join us on March 29th for developer days I'm going to do number two I will add everything I will add a commit message and say update Banner and then I will push my changes and now I can open a port request so let's create and what's going to happen is I have yourself bot here which is creating a preview environment for me or also they refer to them as preview deployments and once that's done I will have an isolated production-like environment where I can preview my changes before merging them so this is going to take a few minutes to build and to set up now I can click on view deployment and I can preview my changes at the top it says number two and this is hosted on a unique URL so I can just share this with anyone and once I get the green light that you know my changes are good I can just merge which is awesome now this flow is great but if you're building an app that is backed by a database things can get a little bit tricky because you will need to provision a database for every pull request and at the same time this preview database you will want to have production data in it so that it accurately reflects production so to do that you will most likely need to import data from an old backup and depending on the size of your database this can take a really long time that's why teams just often skip this step altogether and they just set up a shared database to be used by all previews now this is not ideal because any change made to that preview database will affect all active previews so say for example I'm working in a team and I want to make a change that drops a column in in a table in the database well when I apply my change and any active preview will be using the old database schema so they might be affected or essentially broken so it's kind of like a bottleneck and it's kind of like staging but in Disguise now thankfully it doesn't have to be this way because today I'll show you how you can set up a database for every pull request using versa neon and GitHub actions so without further Ado let's get started neon is fully managed serverless postgres this means you don't have to pick a size for your database up front and it will automatically allocate resources to meet your databases workload now let's see what the experience looks like so right now I'm in the neon console I have an account and I'm logged in and I'm going to create a project so I'll click on create a project I'll call this project demo and I'll choose Europe as my region so immediately I have a connection string that I can use and yeah I have a running postgres instance which is awesome Now by default when you create a project in neon you have a default postgres cluster and within this postgres cluster you can have many databases and by default a database gets automatically created and it's called neon DB now this is important to know because it will help you understand neon branching neon enables you to create copies of your Project's postgres cluster where each copy is completely isolated from the other now we refer to this process as branching and well each copy is called a branch so by default when you created the project the default postgres cluster is represented by a branch called Main and this is the primary branch and whenever we want to create a copy we're going to create a branch from another branch in this case we only have one so it's going to be main now before getting started we don't have any tables right now so I'm going to create a new table and add some data in it and to do that I'll go to the SQL editor and I'm going to add the SQL query so this query creates a new table called elements and it has three columns it has the elements name an atomic number and a symbol so the stable will contain a list of elements that are in the periodic table and then what we're doing is we're inserting the first 10 elements that are in the periodic table in this elements table and number 10 we have neon which is nice so I'll click run and it ran successfully and I can check the data that got added by going to the tables page I will see that I have an elements table and I have 10 items now let's create a copy of this main branch so I'll go to the branches page as you can see we only have one branch this is the main branch and it's the primary branch and let's create a new Branch so I'll give this Branch a name let's call it demo branch and we need to select a parent so this is kind of like the source and the branch that we're going to copy and since we only have one is going to be Main now we have several options when it comes to which data we want included in this new branch in this new copy so we have head which just means we're going to include all of the data up to the current point in time so right now when I click create a branch I will just have all of the data and we have another option which is time so this is different it allows you to include all data up to a certain point in time in the past so this could be within seven days and we plan on making this kind of like window configurable but within seven days you can pick a point in time and this new Branch will include all the data up to that point this is very useful if you want to restore your branch to a previous state and then finally we have LSN which stands for long sequence number which is a pointer in postgres is what I write a headlock so this is even more specific than the time option if you want to revert a branch to a previous state and finally we have configure endpoints so this is how we actually connect to a branch each branch right now has an Associated compute endpoint and this is how you know we have the connection string that we're going to use to connect to that Branch so let's go create and yeah immediately I have a connection string that I can use and this is actually different than the main branch so if I go back to the dashboard you will see I have in the connection details widget I have Branch I click I can choose between the main branch and the demo Branch so for the main branch you can see it's called like epe falling Mouse and then some numbers when I choose the demo Branch it's different it's like epe raspy Bond so each of these two branches are completely isolated and this demo Branch if actually go back to the tables page and I have the demo Branch right here you will see that I have the elements table with all of the data here now to prove that these two branches are completely isolated from one another let's go back to the SQL editor we have the demo Branch selected and I'm going to add a different query so now this just adds 10 more elements and when I click run and I go back to the tables you will see that okay I'm still on demo Branch I'll select elements I now have 20 items in the elements table and if I switch to the main branch you'll see that I still have 10 items which is awesome now this process branching is very very useful in our case which is we want to create a database for each pull request and we're going to see how to do that using versal and GitHub actions we can break down the flow into three phases the first one is local development you can use a neon Branch or if you prefer you can use a local postgres instance once you're happy with your changes which may or may not include database migrations you're going to create a pull request this will trigger a CI CD workflow where you create a neon branch and apply migrations to it you'll then create a preview deployment on versaille if everything looks good and is working as expected you're going to merge the pull request which will trigger another CI CD workflow that will deploy your app to production during this workflow you're going to apply the database migrations to the main branch which includes your production database and create a production deployment to versa finally you're going to delete the old preview Branch since you won't need it anymore to see how this flow looks like I have this demo app that displays the data coming from the elements table that we previously created now this app is built using next.js Prisma neon and is the polluted for sale and for our CI CD pipeline for this project we'll be using GitHub actions which are automated workflows that you define as code and these workflows they live in your Project's repo so the way it works is you have a dog GitHub folder and inside it you define the different workflows in yaml so we have two workflows deploy preview and this workflow is responsible for creating a preview deployment for every pull request and then we have a deploy production workflow which runs whenever we push any commit to our main branch so for example if we have an open power request and we merge that's a trigger this workflow now before actually diving into the code we need to set a bunch of secrets that will be used by these two workflows and to do that we need to go to the action Secrets page and you can find this page by going to the repository settings scrolling to the security section and expanding the secrets and variables drop down and choosing actions and in this page we specify the different secrets and we have a bunch of them so the first one is the database URL this is the database connection string that will be used when we deploy our app to production and then we have a direct database URL and the difference between these two is that the direct database URL doesn't go through a connection Pooler it connects directly to the database and this is required by President migrate to be able to reliably run migrations so that's why we need the two connection strings next we have the neon API key and the neon project ID and we need the neon API key to be able to programmatically create branches so to find these two values what you need to do is go to the account settings pick developer settings and then you can see the list of available API keys that you generated or you can generate a new one I already did it I have a GitHub action API key here and for the project ID what you need to do is go to projects select your project and then go to the project settings from the sidebar and then you can see the project ID here now the last two thing is we need a set of credentials and these will be used when we're creating a branch so here for example the credentials are my name this is the username and then there's the password so we also need to specify these two values as secrets so that when we generate when we create a new neon Branch we will use them as the username and password and finally the last secret we set is the versal token and this is needed so that we can trigger deployments from the GitHub action and it's used to basically authenticate and that's pretty much it so for the result token you will find it in the account settings so you go to settings pick tokens from the sidebar and then you create a new token and whatever value you get here you store it as a secret and that's pretty much it for the secrets now let's actually do a deep dive around the workflow code let's start with the deploy preview workflow now this workflow runs every time we create a pull request and it does the following steps so it runs a single job and it has the following steps so the first step is checkout this enables the workflow to actually access the code that's in our repo what we're then doing is getting the pull request sha or Shaw this is a unique identifier for every git commit and we're getting it because we'll be using it as the branch name whenever we create a branch and the reason we're doing this is after we merge a pull request we want to clean up old unused database branches and we will do that by getting them using this unique identifier so that's why we're getting the poor request sha here and then in the step that's below it what we're doing is we're creating a neon branch and this uses a GitHub action that the neon team has created and it takes the following arguments so first the project ID and we're getting this value from the repository secrets so this is the notation dollar sign double curly braces and then Secrets dot the secret name we're passing the branch name which we're getting from the previous step that's why we're saying steps done get for request sha this is the ID of the previous step and then the outputs which is the output of that previous step and we're getting this value here so because we're echoing the poor request sha here we're able to access it in the next step then what we're doing is running Prisma migrate so the way Prisma migraine Works we're running the first word generating Prisma client and then we're using Prisma migrate deploy and what happens is that prisoner migrate looks inside the migrations folder so it's Prisma slash migrations and then Compares this migrations folder with the database URL so in our case here it's the neon branch that we just created and then we'll see okay do we have any pending migrations are there any migrations that we created as part of the pull request that haven't been applied to this branch that we just created if the answer is no then no pending migrations then we just nothing happens during this step if the answer is yes then we apply the migrations to that newly created neon branch and that's how we'll be able to have a neon branch that contains the latest changes and we're testing these changes in isolation because well a branch doesn't affect any other branches on Neon and then the final four steps on here as we're deploying to Versailles so first we're installing the CLI we're pulling all of the environment variables then we're building the project and then we're deploying it so you deploy it by doing versaille deploy dash dash pre-built because we ran the build command beforehand and then we're passing in the token as a CLI argument and then finally once all of this works we comment on the pull request by showing the versal preview URL and we're getting this from the deploy step here so we have deploy preview of yourself the output called preview URL and that's how we're getting it here and then we're also getting the neon Branch so after we create the branch we'll be able to see the URL here so that we can go to it if we want so let's actually see this in action want to make a new change so to do that I will first I'm on Main I will create a new Branch git Branch to be precise and let's call it update page layout I want to change the layout of the table so that it has like a different style so the way it works I'll go to the page and then here I have a class called grid calls five so let's change this to four for example then I will add all of my changes so I'll get add Dot and then let's say the commit message is change calls number to four and then what I'll do is actually push my changes so I need to send the Upstream then what I'll do is just create a pull request which will trigger this deploy preview workflow that we just saw so now I will create so I actually want this to be in my own fork okay so now I'm going to create a new pull request and we'll see what happens so the first thing you'll notice is that versalbot said one ignore deployment and this is something that I forgot to mention and I disabled the automatic preview deployments that are being created by versel because now we're triggering them using a GitHub action this is to avoid having two preview builds happening at the same time for the same commit which is unnecessary and to do that there is a guide that shows exactly how to do it it's in the Project's readme and all you need to do is in your versel project settings you add then so I added this command and it just checks okay is this production if it is then we build otherwise we don't build and that's why it said ignore build step and to do that you just go to your result project settings so I'll pick my project go to the project settings and then choose git as you know the page and here you can specify a build step that you can ignore so that's how it works so I'm just saying okay if it's production then we exit one which means we run the build step otherwise we exit so now I believe the deployment should be ready let's hope everything works as expected so let's go to poor quests is there running so let's see what happens in a little bit okay all green so all checks have passed so we can see that our deploy preview has worked successfully and you will see that we now have the result preview URL and the neon Branch got created so if we go to the preview URL let's see if everything works as expected it should and we have a different layout so this is deployed so log into common this is virtual specific you can leave comments on preview deployments which are super cool but now you can see that we have a different layout and this is hosted on a different URL then uh then production if you want to go to production this is the URL and they're different so this is like the before and then there is the after so mission accomplished now we have preview deployments that got automatically created and these are full stack preview deployments so they have data coming from the database which is super cool now so now just to double check we can see the branches we can see that we have a branch that got created and it's active because well it's the one that we just created and it's running and we can see the data in it so if we go to tables I'll select this newly created branch and as all of our data which was awesome so that's it for the preview deployment now let's actually take a look at the deployed production workflow so for the deploy production workflow this runs whenever we push a commit to the main branch and the way it works is we have a step where we first check out similar to the other workflow we get the last commit and we're going to use it to find the branch that we just created as part of the preview deployment setup and then we search the branch by name so the way we do it is we do a curl command that lists all of the projects branches so this is the URL and the URL structure is slash project slash project ID slash branches and then we're filtering the response by trying to find the the name and the name should be the Sha of the pull request then we run Prisma migrate so this runs actually on the production database and then again we installed it for cell CLI pull the environment variables build a project but now we deploy to production by specifying the dash dash prod branch and then finally we delete the neon Branch so I actually just merged the poor request which ran this flow and you will see that everything ran successfully so now you can see this job right here and all of these step all these steps just ran so actually now if I go back to the console I should see that I only have my main branch and if that's the case then mission accomplished and if I go now to branches I only have Main and we just cleaned up the branch so now that we merge the change if we actually go to the live website and refresh we will see that the layout has changed which is awesome that's how you can achieve full stack preview deployments using Verso GitHub actions and neon now you can swap out versal with another deployment provider as long as they support the preview environment flow similarly you can also use another tool other than GitHub actions for your CI CD workflows and that's it if you have any questions feel free to reach out to us and other than that thank you so much for tuning in today and we'll see in the next one

a link: https://github.com/neondatabase/preview-branches-with-vercel

video 2

preview deployments have changed the game when it comes to the collaboration process and software development you can easily spin up a production like environment where you can preview your changes before shipping them now one platform that does preview deployments really well is versel you have the seamless experience where you have comments Integrations with issue trackers and it works great when you're building a website but what if you're building an application that is back by a database well you might set up a database that is shared by all previews but then the database becomes a neck because every time you want to introduce a schema change the schema change could affect all active previews and at the same time if you want to test your schema changes in isolation well you're going to have to prevent other developers on your team from also testing their changes so it's not really ideal and the alternative where you try to spin up a database automatically for every preview and seat it with random data well the environment the prev environment you'll end up with will not be truly production like because it doesn't have production like data so what's the solution well today I'm going to show you how to provision a database for every preview where each database is isolated and has production like data let's see how we can do it PP on neon can be branched just like code you can instantly create isolated copies of your pist database where each copy or branch has its own schema and data now here I have two branches I have a main branch and this is the branch that that I'm using in my production deployment and I have a Dev branch that I'm using in local development now the addab benefit of using a branch for local Dev is that this branch has one its own connection string so it's completely isolated from the main branch and this branch has schema and data for me to use so I actually don't need to have any sort of seed script and it just works now what we want to do is actually create a neon Branch for every verel preview deployment and to do that I'm going to use the neon integration that's on versal and to set it up all I need to do is go to the Integrations page choose the versal integration and as you can see connect your versal project to a neon database and enable creating a branch for each preview deployment so I'll click add and here we can see details about the integration we can see that it sets the necessary environment variables in the versal project as well as create a database branch in neon for every GitHub Branch associated with a deployment preview so once we open a p request we will have a neon branch that is associated with this P request that we can use for the preview deployment and all we need to do is just click on ADD from versel this will take us to the Integrations Marketplace I can click add integration choose a versol account to install the integration to I'll choose my own one and I'll choose a specific project this project and I'll click install and now I'm configuring the integration like on the neon side so one I need to select a versel project to add the integration to I only have one so I'll choose it I'll click continue and here I'm configuring the connection string that will be used for my production deployment now I already had a database URL environment variable that I set previously on versel and I removed it before actually starring the setup of this integration so that the integration can set the environment variable for me and here I can specify which database and which rule to use and optionally I can also create a branch for the development environment but I already have one so I'm just going to uncheck this box and click continue now here you can see that the integration sets two environment variables a database URL and this database URL is the pooled connection so this connection supports up to 10,000 simultaneous connections so you never have to worry about running out of connections when deploying your serverless apps on versell and we also are providing the unpooled version of the connection string and all you need to do now is you just click connect and we're done so yeah like right now actually if I go back to the neon console and I refresh I'll actually be able to manage the versal integration so I can click manage and here you can just tweak it uh to your liking so which branch is used uh for for production you have settings regarding which environment variables are set and the default database enroll and if you want to remove the integration you can just disconnected which is convenient now let's actually see what the workflow looks like so here I have an app that's a PL verell and it is a nexs app that is just fetching data from a neon database using Prisma and I'm just rendering the result so if I go to my project and go to my schema. Prisma file you'll see that I have a single table called element where each element has an ID a name a number and a symbol now let's say that I want to you know modify this database schema add a new column and modify my UI so what I'll do is actually just create a new Gib branch and let's say call it like add a new atomic mass column let's say I want to add that and I'll add this field here and thank you copilot and it will have a default value of zero because I already have existing data in my database and now what I'll do is actually generate the migrations for my database and apply them to my neon development branch and I already added the connection string to myv file so all I need to do is just do MPX Prisma migrate Dev and after a moment what will happen is Prisma will ask me to name my migration and if everything works as EXP expected the migrations will be applied and then I can just test my changes and see if everything works as expected and what will happen is we'll just get a new folder here with our migrations and yeah then we'll be able to apply them to a neon Branch whenever we create a new preview so I'll just give it a second and yeah let's give it a name let's call it add new column and the migration was applied so now we see that we have the migration file here and let's say now I want to modify my UI to actually display it so actually if I do mpm run Dev and go to Local Host 3000 you'll see that we already have like the same like UI because again the branch has the same schema and data and now if we actually go back and go to the page and let's say I want to add here and I want to add yeah the atomic mass so I still have autocomplete which is very cool and I'll save and I go here to my editor and I see this value here I'm happy with my changes so you know what I'm happy let me just um you know commit everything and I'll just like let do commit and let's say say um add new column and let's push and set the upstream and then we'll open a new Port request so let's go here and I'm going to create a new P request and I'll just create it now what will happen is a preview deployment will be created by versel and along with this preview deployment we'll have a neon Branch now since our migrations are tracked in code what we'll do is actually apply any pending database migrations to the newly created neon Branch so right now we see actually the preview was deployed and I can visit it and it's authenticating and it's still building so actually if we go to the project settings here I'm in the settings the and then the like build and deployment setting section and you'll see that I actually modified the build command to run npx Prisma migr deploy so this is the command that use to apply the database migrations to your production database and then I'm just generating um Prisma client and then I'm running my regular build so this way what we just did is I tested my changes in isolation using a neon Branch I pushed my changes to GitHub and created a PO request a preview deployment was created for me and I just apply the database migrations that are found in my P request to the newly created neon branch and this way I each preview deployment has its own isolated database with schema and data so now it should be ready and you see that it's ready and if we refresh we have this this is live like this is a preview deployment we get theel toour bar tour bar and it just works which is great so now when we actually merge the PO request what will happen is again there will be the project build step and before that we're just going to apply the schema migrations that are found in code now if you go back to verol we'll actually be able to see the environment variables being set for us so if I go to settings environment variables and I scroll down you'll see that the connection string was set for me for this preview deployment which is awesome and that's it this is how you can have a database for every preview where each database is isolated and has both the schema and data so that you have truly production-like preview environments now if you have any questions feel free to comment down below or reach out to us in the neon Discord Community we' love to hear from you and with that thank you so much for watching and I'll see you in the next one

a link: https://neon.com/blog/branching-with-preview-environments

third link for render

https://render.com/docs/preview-environments





