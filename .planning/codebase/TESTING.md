# Testing Patterns

**Analysis Date:** 2026-02-04

## Test Framework

**Unit & Integration Tests (Backend API):**
- Runner: Vitest 4.0.18
- Config: `backend/api/vitest.config.ts`
- Environment: Node.js
- Test timeout: 10 seconds (can be overridden per test)
- Coverage provider: V8

**E2E Tests (Frontend):**
- Runner: Playwright 1.58.0
- Config: `frontend/playwright.config.ts`
- Test timeout: 30 seconds
- Expect timeout: 10 seconds
- Test directory: `frontend/tests/e2e/`

**Run Commands:**
```bash
# Backend API
cd backend/api && bun run test        # Watch mode
cd backend/api && bun run test:run    # Run once
cd backend/api && bun run test:coverage # With coverage report

# Frontend E2E
cd frontend && bun run test:e2e        # Run all tests
cd frontend && bun run test:e2e:ui     # Interactive UI
cd frontend && bun run test:e2e:debug  # With debugger
cd frontend && bun run test:e2e:report # View HTML report
```

## Test File Organization

**Unit/Integration Tests (Backend):**
- Location: Co-located with source code
- Naming: `filename.test.ts` or `filename.spec.ts`
- Example: `src/routes/health.test.ts` alongside `src/routes/health.ts`
- Pattern: One test file per module/route

**E2E Tests (Frontend):**
- Location: Separate `tests/e2e/` directory
- Naming: `feature.spec.ts`
- Files: `auth.spec.ts`, `chat-streaming.spec.ts`, `entity-resolution.spec.ts`, `tool-approval.spec.ts`
- Fixtures: `tests/e2e/fixtures.ts` (helpers and custom fixtures)
- Setup: `tests/e2e/global.setup.ts` (runs once before all tests)
- Teardown: `tests/e2e/global.teardown.ts` (runs after all tests)
- Mock helpers: `tests/e2e/helpers/mock-sse.ts`
- Auth state: `tests/e2e/.auth/user.json` (generated by setup)

## Test Structure

**Backend Unit Test Pattern (Vitest):**
```typescript
// src/routes/health.test.ts
import { describe, it, expect, vi } from "vitest";
import { Hono } from "hono";
import healthRoutes from "./health";

describe("Health Routes", () => {
  const app = new Hono();
  app.route("/health", healthRoutes);

  describe("GET /health", () => {
    it("should return ok status", async () => {
      const res = await app.request("/health");

      expect(res.status).toBe(200);

      const data = (await res.json()) as { status: string; timestamp: string; uptime: number };
      expect(data).toHaveProperty("status", "ok");
      expect(data).toHaveProperty("timestamp");
      expect(data).toHaveProperty("uptime");
      expect(typeof data.uptime).toBe("number");
    });

    it("should return valid ISO timestamp", async () => {
      const res = await app.request("/health");
      const data = (await res.json()) as { timestamp: string };

      const timestamp = new Date(data.timestamp);
      expect(timestamp.toISOString()).toBe(data.timestamp);
    });
  });

  describe("GET /health/ready", () => {
    it("should return 503 when database is not available", async () => {
      vi.doMock("../db", () => ({
        db: {
          execute: vi.fn().mockRejectedValue(new Error("Connection refused")),
        },
      }));

      const res = await app.request("/health/ready");
      expect([200, 503]).toContain(res.status);
    });
  });
});
```

**Key Patterns:**
- Nested `describe()` blocks for organization
- `it()` blocks with descriptive names (what should happen)
- Type assertions for JSON responses: `as { ... }`
- Mock setup with `vi.doMock()` and `vi.fn()`
- Expect multiple possible responses when testing error conditions

**Frontend E2E Test Pattern (Playwright):**
```typescript
// tests/e2e/auth.spec.ts
import { test as base, expect, type Page } from '@playwright/test';

// Extend test with custom fixtures
const test = base.extend<{ unauthenticatedPage: Page }>({
  unauthenticatedPage: async ({ browser }, use) => {
    const context = await browser.newContext({
      storageState: { cookies: [], origins: [] },
    });
    const page = await context.newPage();
    await use(page);
    await context.close();
  },
});

test.describe('Authentication - Route Protection', () => {
  test('should redirect unauthenticated user to login from chat', async ({
    unauthenticatedPage,
  }) => {
    // Try to access protected route without auth
    await unauthenticatedPage.goto('/chat');

    // Wait for the page to settle
    await unauthenticatedPage.waitForTimeout(3000);

    // Verify redirect or loading state
    const url = unauthenticatedPage.url();
    const isOnLogin = url.includes('/login') || url.includes('/signin');

    expect(isOnLogin || !await chatInput.isVisible()).toBeTruthy();
  });
});
```

**Key Patterns:**
- Extend base test with custom fixtures for specific test contexts
- Use Playwright helpers: `goto()`, `waitForSelector()`, `fill()`, `click()`
- Locators with fallbacks for flexible element selection
- Multiple assertions for resilient tests (handle timing variations)
- Test isolation via fresh contexts/pages

## Mocking

**Backend (Vitest):**
- Framework: Vitest's `vi` module
- Patterns: `vi.fn()`, `vi.doMock()`, `vi.spyOn()`

**Mock Examples:**
```typescript
// Mock function with return value
vi.fn().mockReturnValue(data)

// Mock function with rejected promise (async error)
vi.fn().mockRejectedValue(new Error("DB error"))

// Mock module
vi.doMock("../db", () => ({
  db: {
    execute: vi.fn().mockRejectedValue(new Error("Connection refused")),
  },
}));

// Spy on and restore
afterAll(() => {
  vi.restoreAllMocks();
});
```

**Frontend (Playwright):**
- No Jest/Vitest mocks; instead mock at HTTP level
- Fixture helpers in `tests/e2e/helpers/mock-sse.ts` for mocking SSE streams
- Intercept requests via `page.route()` or `page.on('request')`
- Mock auth state via Playwright's `storageState` in browser context

**What to Mock:**
- External API calls (database, HTTP services)
- Environment-dependent functions
- Time-dependent logic (use fake timers if needed)

**What NOT to Mock:**
- Core application logic (test actual implementations)
- Framework behavior (Hono routing, React rendering)
- Real user interactions (let Playwright interact naturally)

## Fixtures and Factories

**Test Data (Backend):**
- Location: Each test file manages its own fixtures inline
- Pattern: Create test instances within `describe()` blocks

**Test Utilities (Frontend):**
- Location: `tests/e2e/fixtures.ts`
- Common helpers:
  ```typescript
  export const test = base.extend<{ authenticatedPage: Page }>({ ... });
  export async function waitForChatReady(page: Page): Promise<void> { ... }
  export async function sendChatMessage(page: Page, message: string): Promise<void> { ... }
  export async function waitForAIResponse(page: Page, timeout = 30000): Promise<void> { ... }
  export async function waitForToolApproval(page: Page): Promise<void> { ... }
  export async function approveToolExecution(page: Page): Promise<void> { ... }
  export async function denyToolExecution(page: Page): Promise<void> { ... }
  export async function navigateToChat(page: Page): Promise<void> { ... }
  export async function navigateToSettings(page: Page): Promise<void> { ... }
  ```

**Auth Fixture (Frontend):**
- Global setup: `tests/e2e/global.setup.ts`
- Generates authenticated state in `tests/e2e/.auth/user.json`
- State loaded via Playwright config `storageState`
- Tests use authenticated state by default
- Individual tests create fresh context if unauthenticated test needed

## Coverage

**Requirements:** Not enforced (commented out in vitest.config.ts)

**Configuration (`backend/api/vitest.config.ts`):**
```typescript
coverage: {
  provider: "v8",
  reporter: ["text", "json", "html"],
  include: ["src/**/*.ts"],
  exclude: [
    "src/**/*.test.ts",
    "src/**/*.spec.ts",
    "src/**/*.e2e.ts",
    "src/e2e/**",
    "src/db/schema.ts",
    "src/db/seed.ts",
    "src/index.ts",
    "src/env.ts",
    "src/lib/sentry.ts",
  ],
  // TODO: Re-enable thresholds as more tests are added
  // thresholds: { lines: 50, functions: 50, branches: 50, statements: 50 }
}
```

**View Coverage:**
```bash
cd backend/api && bun run test:coverage
# Open coverage report in `coverage/` directory (HTML reporter enabled)
```

**Current State:**
- Minimal test coverage (only health route tested)
- Threshold targets noted but not enforced
- Coverage expected to increase as test suite grows

## Test Types

**Unit Tests (Backend):**
- Scope: Individual functions/routes
- Example: `health.test.ts` tests HTTP endpoint behavior
- Approach: Create minimal test app with Hono, mock dependencies, assert responses

**Integration Tests (Backend):**
- Not yet used; would test database interactions with real database
- Setup: Use test database URL in `setup.ts` (already configured)
- Pattern: Would test route handlers with real DB schemas

**E2E Tests (Frontend):**
- Scope: Complete user workflows (auth, chat, tool approval)
- Framework: Playwright
- Approach: Navigate app, interact with UI, assert DOM state
- Coverage: Critical paths like authentication, chat streaming, tool approval flows

**E2E Test Examples:**
- `auth.spec.ts`: Protected route redirection, login/logout flows
- `chat-streaming.spec.ts`: Sending messages, receiving SSE streams
- `tool-approval.spec.ts`: Tool approval/denial flows
- `smoke.spec.ts`: Basic smoke tests for main features

## Common Patterns

**Async Testing (Backend):**
```typescript
// Vitest handles async functions automatically
it("should return ok status", async () => {
  const res = await app.request("/health");
  expect(res.status).toBe(200);
});

// Or with explicit Promise return
it("should fetch data", () => {
  return asyncFunction().then(result => {
    expect(result).toBeDefined();
  });
});
```

**Async Testing (Frontend):**
```typescript
// Playwright async patterns
test('should show chat', async ({ page }) => {
  await page.goto('/chat');
  await page.waitForSelector('[data-testid="chat-container"]', {
    state: 'visible',
    timeout: 15000,
  });
  expect(page.url()).toContain('/chat');
});
```

**Error Testing (Backend):**
```typescript
it("should return 503 when database is not available", async () => {
  vi.doMock("../db", () => ({
    db: {
      execute: vi.fn().mockRejectedValue(new Error("Connection refused")),
    },
  }));

  const res = await app.request("/health/ready");

  // Allow multiple possible outcomes
  expect([200, 503]).toContain(res.status);

  const data = await res.json();
  expect(data).toHaveProperty("status");
});
```

**Error Testing (Frontend):**
```typescript
test('should handle missing element gracefully', async ({ page }) => {
  await page.goto('/chat');

  // Use .catch() to handle timeout without failing test
  await page.waitForSelector('[data-testid="missing"]', {
    state: 'hidden',
    timeout: 5000,
  }).catch(() => {
    // Element may not exist, that's ok
  });

  // Continue test
  const chatInput = await page.getByPlaceholder(/message/i).first();
  expect(chatInput).toBeDefined();
});
```

**Waiting for Async Operations (Frontend):**
```typescript
// Wait for network idle
await page.waitForLoadState('networkidle', { timeout: 15000 }).catch(() => {
  // Network may not fully idle
});

// Wait for specific element
await page.waitForSelector('[data-testid="chat-loading"]', {
  state: 'hidden',
  timeout: 10000,
}).catch(() => {
  // Loading indicator may not exist
});

// Wait with fallback locators
const element = page.locator('[data-testid="chat-container"]')
  .or(page.locator('[class*="chat-container"]'))
  .or(page.locator('main').filter({ has: page.locator('textarea') }));

await element.first().waitFor({
  state: 'visible',
  timeout: 15000,
});
```

## Setup & Configuration

**Backend Test Setup (`src/test/setup.ts`):**
```typescript
import { beforeAll, afterAll, vi } from "vitest";

beforeAll(() => {
  // Set test environment
  process.env.NODE_ENV = "test";
  process.env.DATABASE_URL = "postgresql://test:test@localhost:5432/test";
  process.env.NEON_AUTH_URL = "https://test.neonauth.test/neondb/auth";
  process.env.TOKEN_ENCRYPTION_SECRET = "test-secret-key-minimum-32-characters-long";
  // ... more env vars
});

afterAll(() => {
  vi.restoreAllMocks();
});
```

**Frontend Test Setup:**
- Global setup: `tests/e2e/global.setup.ts` (authentication, state generation)
- Global teardown: `tests/e2e/global.teardown.ts` (cleanup)
- Browser projects: Chromium desktop + Pixel 5 mobile
- Auth storage: `tests/e2e/.auth/user.json` (generated once, reused across tests)
- Base URL: `PLAYWRIGHT_BASE_URL` env var or `http://localhost:3000`

**CI Configuration:**
```typescript
// Playwright runs with:
// - 2 retries on CI (0 locally)
// - 4 workers on CI (auto locally)
// - GitHub reporter on CI (HTML on failure locally)
// - Screenshots + videos on failure
// - Traces on retry
```

## Best Practices

**Backend:**
- Use type assertions for JSON responses to catch type mismatches
- Mock external dependencies, not Hono framework itself
- Test error paths and edge cases
- Use descriptive test names that read like documentation
- Group related tests with `describe()` blocks

**Frontend:**
- Use `waitFor()` for async state changes (don't use setTimeout)
- Have fallback locators for resilient element selection
- Wrap long waits in `.catch()` when element might not exist
- Test critical user flows (auth, messaging, approvals)
- Use custom fixtures to share test setup
- Avoid testing implementation details; test user interactions

**Both:**
- One assertion per test is ideal; multiple allowed for related checks
- Isolate tests (no test order dependencies)
- Clean up mocks/state in afterAll/teardown
- Document non-obvious test behavior with comments

---

*Testing analysis: 2026-02-04*
